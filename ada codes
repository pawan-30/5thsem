linear-binary search

Code:
#include <bits/stdc++.h>
using namespace std;
bool lSearch(vector<int> v, int n, int t){
    for(int i = 0; i < n; i++) 
    {
        if(v[i] == t) return true;
    }
    return false;
}
bool bSearch(vector<int> v, int n, int t){
    int l = 0;
    int h = n-1;
    while(l<=h){
        int m = (l + ((h-l)>>1));
        if(v[m] == t) return true;
        else if(v[m] < t) l = m+1;
        else h = m-1;
    }
    return false;
}
int main() {
    int n,t;
    int choice = 0;
    cout<<"Menu driven program for Linear and Binary search"<<endl;
    cout<<"Enter the number of elements: ";
    cin>>n;
    vector<int> v(n);
    cout<<"Enter the elements: ";
    for(int i = 0; i< n; i++) cin>>v[i];
    cout<<"What do you want to search? ";
    cin>>t;
    while(choice !=3)
    {
        cout<<"Select any one:-\n'1' for Linear Search\t'2' for Binary Search\t'3' Stop"<<endl;
        cin>>choice;
        switch(choice){
            case 1:
                (lSearch(v,n,t))?cout<<"Element present\n":cout<<"Element not present\n";
                break;
            case 2:
                sort(v.begin(),v.end());
                (bSearch(v,n,t))?cout<<"Element present\n":cout<<"Element not present\n";
                break;
            case 3:
                cout<<"Terminated!";
                exit(0);
            default:
                cout<<"Inavlid input"<<endl;
        }
    }
    return 0;
}
-----------------------------------------------------------------------------------------
bubble sort:

Code:
#include <bits/stdc++.h>
using namespace std;
void bubble_sort(int* arr, int n) {
    for (int i = n - 1; i >= 0; i--) {
        int didSwap = 0;
        for (int j = 0; j <= i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j],arr[j+1]);
                didSwap = 1;
            }
        }
        if(!didSwap) break;
    }
}
int main()
{
    int n;
    cout<<"Enter the number of elements: ";
    cin>>n;
    int arr[n];
    cout<<"Enter the elements: ";
    for(int i = 0; i < n ; i++) cin>>arr[i];
    bubble_sort(arr, n);
    cout << "After using bubble sort: " << "\n";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << "\n";
    return 0;
}
----------------------------------------------------------------------------------------------------------
quick sort:

Code:
#include <bits/stdc++.h>
using namespace std;

int partition(int* arr, int low, int high) {
    int pivot = arr[low];
    int i = low;
    int j = high;

    while (i < j) {
        while (arr[i] <= pivot && i <= high - 1) i++;
        while (arr[j] > pivot && j >= low + 1) j--;
        if (i < j) swap(arr[i], arr[j]);
    }
    swap(arr[low], arr[j]);
    return j;
}

void qs(int* arr, int low, int high) {
    if (low < high) {
        int pIndex = partition(arr, low, high);
        qs(arr, low, pIndex - 1);
        qs(arr, pIndex + 1, high);
    }
}

void quickSort(int* arr,int n) {
    qs(arr, 0, n - 1);
}

int main()
{
    int n;
    cout<<"Enter the number of elements: ";
    cin>>n;
    int arr[n];
    cout<<"Enter the elements: ";
    for(int i=0; i < n; i++) cin>>arr[i];
    quickSort(arr,n);
    cout << "After quick sort: " << "\n";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << "\n";
    return 0;
}
----------------------------------------------------------------------------------------------
heap sort:

Code:
#include <bits/stdc++.h>
using namespace std;
void heapify(vector<int> &v, int n, int i)
{
    int maxIdx = i;
    int leftIdx = 2 * i + 1;
    if (leftIdx < n and v[leftIdx] > v[maxIdx]) maxIdx = leftIdx;
    int rightIdx = 2 * i + 2;
    if (rightIdx < n and v[rightIdx] > v[maxIdx]) maxIdx = rightIdx;
    if (maxIdx != i)
    {
        swap(v[i], v[maxIdx]);
        heapify(v, n, maxIdx);
    }
}
int main()
{
    auto start = chrono::steady_clock::now();
    int n;
    cout<<"Enter the number of elements: ";
    cin>>n;
    vector<int> v(n);
    cout<<"Enter the elements: ";
    for(int i=0; i < n; i++) cin>>v[i];
    for (int i = n - 1; i >= 0; i--) heapify(v, n, i);
    int heapsize = v.size();
    while (heapsize > 1)
    {
        swap(v[0], v[heapsize - 1]);
        heapsize--;
        heapify(v, heapsize, 0);
    }
    cout<<"Sorted elements after Heap sort: "<<endl;
    for (int i = 0; i < v.size(); i++) cout << v[i] << " ";
    cout << endl;
    auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms" <<  endl;
    return 0;
}
-----------------------------------------------------------------------------------------------------------------
merge sort:

Code:
#include <bits/stdc++.h>
using namespace std;

void merge(int* arr, int low, int mid, int high) {
    vector<int> temp;
    int left = low;
    int right = mid + 1;
    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) temp.push_back(arr[left++]);
        else temp.push_back(arr[right++]);
    }
    while (left <= mid)  temp.push_back(arr[left++]);
    while (right <= high) {
        temp.push_back(arr[right]);
        right++;
    }
    for (int i = low; i <= high; i++)   arr[i] = temp[i - low];
}
void mergeSort(int* arr, int low, int high) {
    if (low >= high) return;
    int mid = (low + high) / 2 ;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, mid, high);
}

int main() {
    int n;
    cout<<"Enter the number of elements: ";
    cin>>n;
    int arr[n];
    cout<<"Enter the Elements: ";
    for(int i = 0; i < n; i++) cin>>arr[i];
    mergeSort(arr, 0, n - 1);
    cout << "After Sorting Array: " << endl;
    for (int i = 0; i < n; i++)  cout << arr[i] << " ";
    cout << endl;
    return 0 ;
}
----------------------------------------------------------------------------------------------------
selection sort:

Code:
#include <bits/stdc++.h>
using namespace std;
void selection_sort(int* arr, int n)
{
    for (int i = 0; i < n - 1; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            if (arr[j] < arr[i]) swap(arr[i],arr[j]);
        }
    }
}
int main()
{
    int n;
    cout<<"Enter the number of elements: ";
    cin>>n;
    int arr[n];
    cout<<"Enter the elements: ";
    for(int i = 0; i < n ; i++) cin>>arr[i];
    selection_sort(arr, n);
    cout<<"After selection sort: "<<endl;
    for(int i = 0; i < n; i++) cout<<arr[i]<<" ";
    cout<<endl;
    return 0;
}
---------------------------------------------------------------------------------------------------
minimum spanning tree:

Code:
#include <bits/stdc++.h>
using namespace std;
struct Edge {
    int src, dest, weight;
};
bool compareEdges(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}
void kruskalMST(vector<Edge> edges, int V) {
    sort(edges.begin(), edges.end(), compareEdges);
    vector<int> parent(V);
    vector<int> rank(V, 0);
    for (int i = 0; i < V; i++) {
        parent[i] = i;
    }
    vector<Edge> result;
    for (Edge edge : edges) {
        int x = edge.src;
        int y = edge.dest;
        while (parent[x] != x)
            x = parent[x];
        while (parent[y] != y)
            y = parent[y];
        if (x != y) {
            result.push_back(edge);
            if (rank[x] < rank[y])
                parent[x] = y;
            else if (rank[x] > rank[y])
                parent[y] = x;
            else {
                parent[y] = x;
                rank[x]++;
            }
        }
    }
    cout << "Kruskal's Algorithm - Edges in Minimum Spanning Tree:" << endl;
    for (Edge edge : result) {
        cout << edge.src << " - " << edge.dest << " : " << edge.weight << endl;
    }
}
void primMST(vector<vector<int>> &graph, int V) {
    vector<int> parent(V, -1);
    vector<int> key(V, INT_MAX);
    key[0] = 0;
    vector<bool> inMST(V, false);
    for (int count = 0; count < V - 1; count++) {
        int u = -1;
        for (int v = 0; v < V; v++) {
            if (!inMST[v] && (u == -1 || key[v] < key[u]))
                u = v;
        }
        inMST[u] = true;
        for (int v = 0; v < V; v++) {
            if (graph[u][v] && !inMST[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }
    cout << "\nPrim's Algorithm - Edges in Minimum Spanning Tree:" << endl;
    for (int i = 1; i < V; i++) {
        cout << parent[i] << " - " << i << " : " << graph[i][parent[i]] << endl;
    }
}
int main() {
    auto start = chrono::steady_clock::now();
    int V = 4;
    vector<Edge> edges = {
        {0, 1, 10},
        {0, 2, 6},
        {0, 3, 5},
        {1, 3, 15},
        {2, 3, 4}
    };
    kruskalMST(edges, V);
    vector<vector<int>> graph = {
        {0, 10, 6, 5},
        {10, 0, 0, 15},
        {6, 0, 0, 4},
        {5, 15, 4, 0}
    };
    primMST(graph, V);
    auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms\n";
    return 0;
}
----------------------------------------------------------------------------------------------------------
matrix multiplication:

Code:
#include <bits/stdc++.h>
using namespace std;
vector<vector<int>> matrixMultiplication(vector<vector<int>> &a, vector<vector<int>> &b) {
  int n = a.size();
  int m = b[0].size();
  vector<vector<int>> c(n, vector<int>(m, 0));
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      for (int k = 0; k < a[0].size(); k++) {
        c[i][j] += a[i][k] * b[k][j];
      }
    }
  }
  return c;
}
int main() {
  vector<vector<int>> a = {{1, 2}, {3, 4}};
  vector<vector<int>> b = {{5, 6}, {7, 8}};
  cout<<"Matrix 1 :-\n";
  for(auto x : a){
      for(auto y : x) cout<<y<<" ";
      cout<<endl;
  }
  cout<<"Matrix 2 :-\n";
  for(auto x : b){
      for(auto y : x) cout<<y<<" ";
      cout<<endl;
  }
  auto start = chrono::steady_clock::now();
  vector<vector<int>> c = matrixMultiplication(a, b);
  cout<<"Result matrix:-\n";
  for (int i = 0; i < c.size(); i++) {
    for (int j = 0; j < c[0].size(); j++) {
      cout << c[i][j] << " ";
    }
    cout << endl;
  }
   auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms\n";
  return 0;
}
------------------------------------------------------------------------------------------------------------
bellman ford:

Code:
#include <bits/stdc++.h>
using namespace std;
struct Edge {
    int src, dest, weight;
};
class Graph {
    int V, E;
    vector<Edge> edges;
public:
    Graph(int vertices, int edgesCount) : V(vertices), E(edgesCount) {}
    void addEdge(int src, int dest, int weight) {
        edges.push_back({src, dest, weight});
    }
    void bellmanFord(int startVertex) {
        vector<int> distance(V, INT_MAX);
        distance[startVertex] = 0;
        for (int i = 0; i < V - 1; ++i) {
            for (const Edge& edge : edges) {
                if (distance[edge.src] != INT_MAX && distance[edge.src] + edge.weight < distance[edge.dest]) {
                    distance[edge.dest] = distance[edge.src] + edge.weight;
                }
            }
        }
        for (const Edge& edge : edges) {
            if (distance[edge.src] != INT_MAX && distance[edge.src] + edge.weight < distance[edge.dest]) {
                cout << "Graph contains negative weight cycle. Bellman-Ford does not work for such graphs.\n";
                return;
            }
        }
        cout << "Vertex   Distance from Source\n";
        for (int i = 0; i < V; ++i) {
            cout << i << "\t\t" << distance[i] << endl;
        }
    }
};

int main() {
    int V, E;
    cout << "Enter the number of vertices and edges: ";
    cin >> V >> E;
    Graph graph(V, E);
    cout << "Enter the edges (source, destination, weight):\n";
    for (int i = 0; i < E; ++i) {
        int src, dest, weight;
        cin >> src >> dest >> weight;
        graph.addEdge(src, dest, weight);
    }
    int startVertex;
    cout << "Enter the starting vertex: ";
    cin >> startVertex;
    auto start = chrono::steady_clock::now();
    graph.bellmanFord(startVertex);
    auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms\n";
    return 0;
}
-----------------------------------------------------------------------------------------------------------
Nqueen:

Code:
#include <bits/stdc++.h>
using namespace std;
class Solution {
  public: void solve(int col, vector < string > & board, vector < vector < string >> & ans, vector < int > & leftrow, vector < int > & upperDiagonal, vector < int > & lowerDiagonal, int n) {
    if (col == n) {
      ans.push_back(board);
      return;
    }
    for (int row = 0; row < n; row++) {
      if (leftrow[row] == 0 && lowerDiagonal[row + col] == 0 && upperDiagonal[n - 1 + col - row] == 0) {
        board[row][col] = 'Q';
        leftrow[row] = 1;
        lowerDiagonal[row + col] = 1;
        upperDiagonal[n - 1 + col - row] = 1;
        solve(col + 1, board, ans, leftrow, upperDiagonal, lowerDiagonal, n);
        board[row][col] = '.';
        leftrow[row] = 0;
        lowerDiagonal[row + col] = 0;
        upperDiagonal[n - 1 + col - row] = 0;
      }
    }
  }
  public: vector < vector < string >> solveNQueens(int n) {
    vector < vector < string >> ans;
    vector < string > board(n);
    string s(n, '.');
    for (int i = 0; i < n; i++) board[i] = s;
    vector < int > leftrow(n, 0), upperDiagonal(2 * n - 1, 0), lowerDiagonal(2 * n - 1, 0);
    solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n);
    return ans;
  }
};
int main() {
  int n;
  cout << "Enter the value of n: ";
  cin >> n;
  Solution obj;
  vector < vector < string >> ans = obj.solveNQueens(n);
  for (int i = 0; i < ans.size(); i++) {
    cout << "Arrangement " << i + 1 << "\n";
    for (int j = 0; j < ans[0].size(); j++) {
      cout << ans[i][j];
      cout << endl;
    }
  }
  return 0;
}
-----------------------------------------------------------------------------------------------------
LCS:

Code:

#include <bits/stdc++.h>
using namespace std;
int lcsUtil(string& s1, string& s2, int ind1, int ind2, vector<vector<int>>& dp) {
    if (ind1 < 0 || ind2 < 0) return 0;
    if (dp[ind1][ind2] != -1)
        return dp[ind1][ind2];
    if (s1[ind1] == s2[ind2])
        return dp[ind1][ind2] = 1 + lcsUtil(s1, s2, ind1 - 1, ind2 - 1, dp);
    else
        return dp[ind1][ind2] = max(lcsUtil(s1, s2, ind1, ind2 - 1, dp), lcsUtil(s1, s2, ind1 - 1, ind2, dp));
}
int lcs(string s1, string s2) {
    int n = s1.size();
    int m = s2.size();
    vector<vector<int>> dp(n, vector<int>(m, -1));
    return lcsUtil(s1, s2, n - 1, m - 1, dp);
}
int main() {
    string s1,s2;
    cout<<"Enter String 1: ";
    cin>>s1;
    cout<<"Enter String 2: ";
    cin>>s2;
    auto start = chrono::steady_clock::now();
    cout << "The Length of Longest Common Subsequence is " << lcs(s1, s2) << endl;
    auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms\n";
    return 0;
}
-----------------------------------------------------------------------------------------------------------------
huffman coding:

Code:
#include <bits/stdc++.h>
using namespace std;
struct HuffmanNode {
    char data;
    unsigned frequency;
    HuffmanNode *left, *right;
    HuffmanNode(char data, unsigned frequency) : data(data), frequency(frequency), left(nullptr), right(nullptr) {}
};
struct Compare {
    bool operator()(HuffmanNode* a, HuffmanNode* b) {
        return a->frequency > b->frequency;
    }
};
HuffmanNode* buildHuffmanTree(const string& text) {
    unordered_map<char, unsigned> frequencyMap;
    for (char ch : text) {
        frequencyMap[ch]++;
    }
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, Compare> minHeap;
    for (auto& entry : frequencyMap) {
        minHeap.push(new HuffmanNode(entry.first, entry.second));
    }
    while (minHeap.size() > 1) {
        HuffmanNode* left = minHeap.top();
        minHeap.pop();
        HuffmanNode* right = minHeap.top();
        minHeap.pop();
        HuffmanNode* newNode = new HuffmanNode('$', left->frequency + right->frequency);
        newNode->left = left;
        newNode->right = right;
        minHeap.push(newNode);
    }
    return minHeap.top();
}
void generateCodes(HuffmanNode* root, string code, unordered_map<char, string>& huffmanCodes) {
    if (root) {
        if (!root->left && !root->right) {
            huffmanCodes[root->data] = code;
        }
        generateCodes(root->left, code + "0", huffmanCodes);
        generateCodes(root->right, code + "1", huffmanCodes);
    }
}
string encodeText(const string& text, const unordered_map<char, string>& huffmanCodes) {
    string encodedText = "";
    for (char ch : text) {
        encodedText += huffmanCodes.at(ch);
    }
    return encodedText;
}
int main() {
    auto start = chrono::steady_clock::now();
    string text;
    cout<<"Enter the text: ";
    cin>>text;
    HuffmanNode* root = buildHuffmanTree(text);
    unordered_map<char, string> huffmanCodes;
    generateCodes(root, "", huffmanCodes);
    string encodedText = encodeText(text, huffmanCodes);
    cout << "Huffman Codes:\n";
    for (const auto& entry : huffmanCodes) {
        cout << entry.first << ": " << entry.second << endl;
    }
    cout << "Encoded Text: " << encodedText << endl;
    auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms\n";
    return 0;
}
---------------------------------------------------------------------------------------------------
dijkstras:

Code:
#include <bits/stdc++.h>
using namespace std;
struct Node {
    int vertex;
    int distance;
};
struct CompareNode {
    bool operator()(const Node& a, const Node& b) {
        return a.distance > b.distance;
    }
};
class Dijkstra {
private:
    int vertices;
    vector<vector<pair<int, int>>> adjList;
public:
    Dijkstra(int V) : vertices(V), adjList(V) {}
    void addEdge(int u, int v, int w) {
        adjList[u].push_back(make_pair(v, w));
        adjList[v].push_back(make_pair(u, w));
    }
    void dijkstra(int src) {
        vector<int> distance(vertices, INT_MAX);
        distance[src] = 0;
        priority_queue<Node, vector<Node>, CompareNode> pq;
        pq.push({src, 0});
        while (!pq.empty()) {
            int u = pq.top().vertex;
            pq.pop();
            for (const auto& neighbor : adjList[u]) {
                int v = neighbor.first;
                int w = neighbor.second;
                if (distance[v] > distance[u] + w) {
                    distance[v] = distance[u] + w;
                    pq.push({v, distance[v]});
                }
            }
        }
        cout << "Shortest distances from source " << src << ":\n";
        for (int i = 0; i < vertices; ++i) {
            cout << "Vertex " << i << ": ";
            if (distance[i] == INT_MAX) cout<<"INF\n";
            else cout<<distance[i]<< "\n";
        }
    }
};
int main() {
    auto start = chrono::steady_clock::now();
    Dijkstra graph(5);
    graph.addEdge(0, 1, 2);
    graph.addEdge(0, 2, 4);
    graph.addEdge(1, 2, 1);
    graph.addEdge(1, 3, 7);
    graph.addEdge(2, 4, 3);
    graph.addEdge(3, 4, 1);
    graph.dijkstra(0);
    auto end = chrono::steady_clock::now();
    auto diff = end - start;
    cout <<"Execution time: "<< chrono::duration <double, milli> (diff).count() << " ms\n";
    return 0;
}
----------------------------------------------------------------------------------------------------------
string match:

Code:
#include <bits/stdc++.h>
#include <chrono>
using namespace std;
using namespace std::chrono;
// Naive String Matching Algorithm
void naiveStringMatching(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();
    for (int i = 0; i <= n - m; ++i) {
        int j;
        for (j = 0; j < m; ++j)
            if (text[i + j] != pattern[j])
                break;
        if (j == m)
            cout << "Naive: Pattern found at index " << i << endl;
    }
}
// Rabin-Karp Algorithm
void rabinKarp(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();
    int prime = 101; // A prime number
    int patternHash = 0;
    int textHash = 0;
    for (int i = 0; i < m; ++i) {
        patternHash += pattern[i] * pow(prime, i);
        textHash += text[i] * pow(prime, i);
    }
    for (int i = 0; i <= n - m; ++i) {
        if (patternHash == textHash) {
            int j;
            for (j = 0; j < m; ++j)
                if (text[i + j] != pattern[j])
                    break;
            if (j == m)
                cout << "Rabin-Karp: Pattern found at index " << i << endl;
        }
        if (i < n - m) {
            textHash = (textHash - text[i] + text[i + m] * pow(prime, m - 1)) * prime;
        }
    }
}
// Knuth-Morris-Pratt Algorithm
void buildLPS(const string& pattern, int* lps) {
    int m = pattern.length();
    int len = 0;
    lps[0] = 0;
    int i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0)
                len = lps[len - 1];
            else {
                lps[i] = 0;
                i++;
            }
        }
    }
}
void kmp(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();
    int* lps = new int[m];
    buildLPS(pattern, lps);
    int i = 0, j = 0;
    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }
        if (j == m) {
            cout << "KMP: Pattern found at index " << i - j << endl;
            j = lps[j - 1];
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }
    delete[] lps;
}
int main() {
    string text, pattern;
    cout << "Enter the text: ";
    getline(cin, text);
    cout << "Enter the pattern: ";
    getline(cin, pattern);
    auto start = high_resolution_clock::now();
    naiveStringMatching(text, pattern);
    auto stop = high_resolution_clock::now();
    auto naiveDuration = duration_cast<microseconds>(stop - start);
    start = high_resolution_clock::now();
    rabinKarp(text, pattern);
    stop = high_resolution_clock::now();
    auto rabinKarpDuration = duration_cast<microseconds>(stop - start);
    start = high_resolution_clock::now();
    kmp(text, pattern);
    stop = high_resolution_clock::now();
    auto kmpDuration = duration_cast<microseconds>(stop - start);
    cout << "Naive String Matching Time: " << naiveDuration.count() << " microseconds" << endl;
    cout << "Rabin-Karp Time: " << rabinKarpDuration.count() << " microseconds" << endl;
    cout << "KMP Time: " << kmpDuration.count() << " microseconds" << endl;
    return 0;
}
